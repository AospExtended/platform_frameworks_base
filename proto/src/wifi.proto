/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto2";

package clearcut.connectivity;

option java_package = "com.android.server.wifi";
option java_outer_classname = "WifiMetricsProto";

// The information about the Wifi events.
message WifiLog {

  // Session information that gets logged for every Wifi connection.
  repeated ConnectionEvent connection_event = 1;

  // Number of saved networks in the user profile.
  optional int32 num_saved_networks = 2;

  // Number of open networks in the saved networks.
  optional int32 num_open_networks = 3;

  // Number of legacy personal networks.
  optional int32 num_legacy_personal_networks = 4;

  // Number of legacy enterprise networks.
  optional int32 num_legacy_enterprise_networks = 5;

  // Does the user have location setting enabled.
  optional bool is_location_enabled = 6;

  // Does the user have scanning enabled.
  optional bool is_scanning_always_enabled = 7;

  // Number of times user toggled wifi using the settings menu.
  optional int32 num_wifi_toggled_via_settings = 8;

  // Number of times user toggled wifi using the airplane menu.
  optional int32 num_wifi_toggled_via_airplane = 9;

  // Number of networks added by the user.
  optional int32 num_networks_added_by_user = 10;

  // Number of networks added by applications.
  optional int32 num_networks_added_by_apps = 11;

  // Number scans that returned empty results.
  optional int32 num_empty_scan_results = 12;

  // Number scans that returned at least one result.
  optional int32 num_non_empty_scan_results = 13;

  // Number of single scans requests.
  optional int32 num_oneshot_scans = 14;

  // Number of repeated background scans that were scheduled to the chip.
  optional int32 num_background_scans = 15;

  // Error codes that a scan can result in.
  enum ScanReturnCode {

    // Return Code is unknown.
    SCAN_UNKNOWN = 0;

    // Scan was successful.
    SCAN_SUCCESS = 1;

    // Scan was successfully started, but was interrupted.
    SCAN_FAILURE_INTERRUPTED = 2;

    //  Scan failed to start because of invalid configuration
    //  (bad channel, etc).
    SCAN_FAILURE_INVALID_CONFIGURATION = 3;

    // Could not start a scan because wifi is disabled.
    FAILURE_WIFI_DISABLED = 4;

  }

  // Mapping of error codes to the number of times that scans resulted
  // in that error.
  repeated ScanReturnEntry scan_return_entries = 16;

  message ScanReturnEntry {

    // Return code of the scan.
    optional ScanReturnCode scan_return_code = 1;

    // Number of entries that were found in the scan.
    optional int32 scan_results_count = 2;
  }

  // State of the Wifi.
  enum WifiState {

    // State is unknown.
    WIFI_UNKNOWN = 0;

    // Wifi is disabled.
    WIFI_DISABLED = 1;

    // Wifi is enabled.
    WIFI_DISCONNECTED = 2;

    // Wifi is enabled and associated with an AP.
    WIFI_ASSOCIATED = 3;
  }

  // Mapping of system state to the number of times that scans were requested in
  // that state
  repeated WifiSystemStateEntry wifi_system_state_entries = 17;

  message WifiSystemStateEntry {

    // Current WiFi state.
    optional WifiState wifi_state = 1;

    // Count of scans in state.
    optional int32 wifi_state_count = 2;

    // Is screen on.
    optional bool is_screen_on = 3;
  }

  // Mapping of Error/Success codes to the number of background scans that resulted in it
  repeated ScanReturnEntry background_scan_return_entries = 18;

  // Mapping of system state to the number of times that Background scans were requested in that
  // state
  repeated WifiSystemStateEntry background_scan_request_state = 19;

  // Total number of times the Watchdog of Last Resort triggered, resetting the wifi stack
  optional int32 num_last_resort_watchdog_triggers = 20;

  // Total number of networks over bad association threshold when watchdog triggered
  optional int32 num_last_resort_watchdog_bad_association_networks_total = 21;

  // Total number of networks over bad authentication threshold when watchdog triggered
  optional int32 num_last_resort_watchdog_bad_authentication_networks_total = 22;

  // Total number of networks over bad dhcp threshold when watchdog triggered
  optional int32 num_last_resort_watchdog_bad_dhcp_networks_total = 23;

  // Total number of networks over bad other threshold when watchdog triggered
  optional int32 num_last_resort_watchdog_bad_other_networks_total = 24;

  // Total count of networks seen when watchdog triggered
  optional int32 num_last_resort_watchdog_available_networks_total = 25;

  // Total count of triggers with atleast one bad association network
  optional int32 num_last_resort_watchdog_triggers_with_bad_association = 26;

  // Total count of triggers with atleast one bad authentication network
  optional int32 num_last_resort_watchdog_triggers_with_bad_authentication = 27;

  // Total count of triggers with atleast one bad dhcp network
  optional int32 num_last_resort_watchdog_triggers_with_bad_dhcp = 28;

  // Total count of triggers with atleast one bad other network
  optional int32 num_last_resort_watchdog_triggers_with_bad_other = 29;

  // Count of times connectivity watchdog confirmed pno is working
  optional int32 num_connectivity_watchdog_pno_good = 30;

  // Count of times connectivity watchdog found pno not working
  optional int32 num_connectivity_watchdog_pno_bad = 31;

  // Count of times connectivity watchdog confirmed background scan is working
  optional int32 num_connectivity_watchdog_background_good = 32;

  // Count of times connectivity watchdog found background scan not working
  optional int32 num_connectivity_watchdog_background_bad = 33;

  // The time duration represented by this wifi log, from start to end of capture
  optional int32 record_duration_sec = 34;

  // Counts the occurrences of each individual RSSI poll level
  repeated RssiPollCount rssi_poll_rssi_count = 35;

  // Total number of times WiFi connected immediately after a Last Resort Watchdog trigger,
  // without new networks becoming available.
  optional int32 num_last_resort_watchdog_successes = 36;

  // Total number of saved hidden networks
  optional int32 num_hidden_networks = 37;

  // Total number of saved passpoint / hotspot 2.0 networks
  optional int32 num_passpoint_networks = 38;

  // Total number of scan results
  optional int32 num_total_scan_results = 39;

  // Total number of scan results for open networks
  optional int32 num_open_network_scan_results = 40;

  // Total number of scan results for legacy personal networks
  optional int32 num_legacy_personal_network_scan_results = 41;

  // Total number of scan results for legacy enterprise networks
  optional int32 num_legacy_enterprise_network_scan_results = 42;

  // Total number of scan results for hidden networks
  optional int32 num_hidden_network_scan_results = 43;

  // Total number of scan results for hotspot 2.0 r1 networks
  optional int32 num_hotspot2_r1_network_scan_results = 44;

  // Total number of scan results for hotspot 2.0 r2 networks
  optional int32 num_hotspot2_r2_network_scan_results = 45;

  // Total number of scans handled by framework (oneshot or otherwise)
  optional int32 num_scans = 46;

  // Counts the occurrences of each alert reason.
  repeated AlertReasonCount alert_reason_count = 47;

  // Counts the occurrences of each Wifi score
  repeated WifiScoreCount wifi_score_count = 48;

  // Histogram of Soft AP Durations
  repeated SoftApDurationBucket soft_ap_duration = 49;

  // Histogram of Soft AP ReturnCode
  repeated SoftApReturnCodeCount soft_ap_return_code = 50;

  // Histogram of the delta between scan result RSSI and RSSI polls
  repeated RssiPollCount rssi_poll_delta_count = 51;

  // List of events
  repeated StaEvent sta_event_list = 52;

  // Total number of times WiFi HAL crashed.
  optional int32 num_hal_crashes = 53;

  // Total number of times WiFicond crashed.
  optional int32 num_wificond_crashes = 54;

  // Indicates the number of times an error was encountered in
  // Wifi HAL on |WifiNative.setupInterfaceForClientMode|.
  optional int32 num_setup_client_interface_failure_due_to_hal = 55;

  // Indicates the number of times an error was encountered in
  // Wificond on |WifiNative.setupInterfaceForClientMode|.
  optional int32 num_setup_client_interface_failure_due_to_wificond = 56;

  // Wi-Fi Aware metrics
  optional WifiAwareLog wifi_aware_log = 57;

  // Number of saved Passpoint providers in user profile.
  optional int32 num_passpoint_providers = 58;

  // Count of times Passpoint provider being installed.
  optional int32 num_passpoint_provider_installation = 59;

  // Count of times Passpoint provivider is installed successfully.
  optional int32 num_passpoint_provider_install_success = 60;

  // Count of times Passpoint provider is being uninstalled.
  optional int32 num_passpoint_provider_uninstallation = 61;

  // Count of times Passpoint provider is uninstalled successfully.
  optional int32 num_passpoint_provider_uninstall_success = 62;

  // Count of saved Passpoint providers device has ever connected to.
  optional int32 num_passpoint_providers_successfully_connected = 63;

  // Histogram counting instances of scans with N many ScanResults with unique ssids
  repeated NumConnectableNetworksBucket total_ssids_in_scan_histogram = 64;

  // Histogram counting instances of scans with N many ScanResults/bssids
  repeated NumConnectableNetworksBucket total_bssids_in_scan_histogram = 65;

  // Histogram counting instances of scans with N many unique open ssids
  repeated NumConnectableNetworksBucket available_open_ssids_in_scan_histogram = 66;

  // Histogram counting instances of scans with N many bssids for open networks
  repeated NumConnectableNetworksBucket available_open_bssids_in_scan_histogram = 67;

  // Histogram counting instances of scans with N many unique ssids for saved networks
  repeated NumConnectableNetworksBucket available_saved_ssids_in_scan_histogram = 68;

  // Histogram counting instances of scans with N many bssids for saved networks
  repeated NumConnectableNetworksBucket available_saved_bssids_in_scan_histogram = 69;

  // Histogram counting instances of scans with N many unique SSIDs for open or saved networks
  repeated NumConnectableNetworksBucket available_open_or_saved_ssids_in_scan_histogram = 70;

  // Histogram counting instances of scans with N many BSSIDs for open or saved networks
  repeated NumConnectableNetworksBucket available_open_or_saved_bssids_in_scan_histogram = 71;

  // Histogram counting instances of scans with N many ScanResults matching unique saved passpoint providers
  repeated NumConnectableNetworksBucket available_saved_passpoint_provider_profiles_in_scan_histogram = 72;

  // Histogram counting instances of scans with N many ScanResults BSSIDs matching a saved passpoint provider
  repeated NumConnectableNetworksBucket available_saved_passpoint_provider_bssids_in_scan_histogram = 73;

  // Counts the number of AllSingleScanLister.onResult calls with a full band scan result
  optional int32 full_band_all_single_scan_listener_results = 74;

  // Counts the number of AllSingleScanLister.onResult calls with a partial (channels) scan result
  optional int32 partial_all_single_scan_listener_results = 75;

  // Pno scan metrics
  optional PnoScanMetrics pno_scan_metrics = 76;

  // Histogram of "Connect to Network" notifications.
  // The notification Action should be unset.
  repeated ConnectToNetworkNotificationAndActionCount connect_to_network_notification_count = 77;

  // Histogram of "Connect to Network" notification user actions.
  repeated ConnectToNetworkNotificationAndActionCount connect_to_network_notification_action_count = 78;

  // The number of SSIDs blacklisted from recommendation by the open network
  // notification recommender
  optional int32 open_network_recommender_blacklist_size = 79;

  // Is the available network notification feature turned on
  optional bool is_wifi_networks_available_notification_on = 80;

  // Count of recommendation updates made by the open network notification
  // recommender
  optional int32 num_open_network_recommendation_updates = 81;

  // Count of connection attempts that were initiated unsuccessfully
  optional int32 num_open_network_connect_message_failed_to_send = 82;

  // Histogram counting instances of scans with N many HotSpot 2.0 R1 APs
  repeated NumConnectableNetworksBucket observed_hotspot_r1_aps_in_scan_histogram = 83;

  // Histogram counting instances of scans with N many HotSpot 2.0 R2 APs
  repeated NumConnectableNetworksBucket observed_hotspot_r2_aps_in_scan_histogram = 84;

  // Histogram counting instances of scans with N many unique HotSpot 2.0 R1 ESS.
  // Where ESS is defined as the (HESSID, ANQP Domain ID), (SSID, ANQP Domain ID) or
  // (SSID, BSSID) tuple depending on AP configuration (in the above priority
  // order).
  repeated NumConnectableNetworksBucket observed_hotspot_r1_ess_in_scan_histogram = 85;

  // Histogram counting instances of scans with N many unique HotSpot 2.0 R2 ESS.
  // Where ESS is defined as the (HESSID, ANQP Domain ID), (SSID, ANQP Domain ID) or
  // (SSID, BSSID) tuple depending on AP configuration (in the above priority
  // order).
  repeated NumConnectableNetworksBucket observed_hotspot_r2_ess_in_scan_histogram = 86;

  // Histogram counting number of HotSpot 2.0 R1 APs per observed ESS in a scan
  // (one value added per unique ESS - potentially multiple counts per single
  // scan!)
  repeated NumConnectableNetworksBucket observed_hotspot_r1_aps_per_ess_in_scan_histogram = 87;

  // Histogram counting number of HotSpot 2.0 R2 APs per observed ESS in a scan
  // (one value added per unique ESS - potentially multiple counts per single
  // scan!)
  repeated NumConnectableNetworksBucket observed_hotspot_r2_aps_per_ess_in_scan_histogram = 88;

  // SoftAP event list tracking sessions and client counts in tethered mode
  repeated SoftApConnectedClientsEvent soft_ap_connected_clients_events_tethered = 89;

  // SoftAP event list tracking sessions and client counts in local only mode
  repeated SoftApConnectedClientsEvent soft_ap_connected_clients_events_local_only = 90;

  // Wps connection metrics
  optional WpsMetrics wps_metrics = 91;

  // Wifi power statistics
  optional WifiPowerStats wifi_power_stats = 92;

  // Number of connectivity single scan requests.
  optional int32 num_connectivity_oneshot_scans = 93;

  // WifiWake statistics
  optional WifiWakeStats wifi_wake_stats = 94;

  // Histogram counting instances of scans with N many 802.11mc (RTT) supporting APs
  repeated NumConnectableNetworksBucket observed_80211mc_supporting_aps_in_scan_histogram = 95;

  // Total number of times supplicant crashed.
  optional int32 num_supplicant_crashes = 96;

  // Total number of times hostapd crashed.
  optional int32 num_hostapd_crashes = 97;

  // Indicates the number of times an error was encountered in
  // supplicant on |WifiNative.setupInterfaceForClientMode|.
  optional int32 num_setup_client_interface_failure_due_to_supplicant = 98;

  // Indicates the number of times an error was encountered in
  // Wifi HAL on |WifiNative.setupInterfaceForSoftApMode|.
  optional int32 num_setup_soft_ap_interface_failure_due_to_hal = 99;

  // Indicates the number of times an error was encountered in
  // Wifi HAL on |WifiNative.setupInterfaceForSoftApMode|.
  optional int32 num_setup_soft_ap_interface_failure_due_to_wificond = 100;

  // Indicates the number of times an error was encountered in
  // Wifi HAL on |WifiNative.setupInterfaceForSoftApMode|.
  optional int32 num_setup_soft_ap_interface_failure_due_to_hostapd = 101;

  // Indicates the number of times we got an interface down in client mode.
  optional int32 num_client_interface_down = 102;

  // Indicates the number of times we got an interface down in softap mode.
  optional int32 num_soft_ap_interface_down = 103;

  // Indicates the number of scan requests from external apps.
  optional int32 num_external_app_oneshot_scan_requests = 104;

  // Indicates the number of times a scan request from an external foreground app was throttled.
  optional int32 num_external_foreground_app_oneshot_scan_requests_throttled = 105;

  // Indicates the number of times a scan request from an external background app was throttled.
  optional int32 num_external_background_app_oneshot_scan_requests_throttled = 106;

  // WifiLastResortWatchdog time milliseconds delta between trigger and first connection success
  optional int64 watchdog_trigger_to_connection_success_duration_ms = 107 [default = -1];

  // The number of times wifi experienced failures after watchdog has already been triggered and is
  // waiting for a connection success
  optional int64 watchdog_total_connection_failure_count_after_trigger = 108;

  // Number of times DFS channel scans are requested in single scan requests.
  optional int32 num_oneshot_has_dfs_channel_scans = 109;

  // Wi-Fi RTT metrics
  optional WifiRttLog wifi_rtt_log = 110;

  // Flag which indicates if Connected MAC Randomization is enabled
  optional bool is_mac_randomization_on = 111 [default = false];

  // Number of radio mode changes to MCC (Multi channel concurrency).
  optional int32 num_radio_mode_change_to_mcc = 112;

  // Number of radio mode changes to SCC (Single channel concurrency).
  optional int32 num_radio_mode_change_to_scc = 113;

  // Number of radio mode changes to SBS (Single band simultaneous).
  optional int32 num_radio_mode_change_to_sbs = 114;

  // Number of radio mode changes to DBS (Dual band simultaneous).
  optional int32 num_radio_mode_change_to_dbs = 115;

  // Number of times the firmware picked a SoftAp channel not satisfying user band preference.
  optional int32 num_soft_ap_user_band_preference_unsatisfied = 116;

  // Identifier for experimental scoring parameter settings.
  optional string score_experiment_id = 117;

  // Data on wifi radio usage
  optional WifiRadioUsage wifi_radio_usage = 118;

  // Stores settings values used for metrics testing.
  optional ExperimentValues experiment_values = 119;

  // List of WifiIsUnusableEvents which get logged when we notice that WiFi is unusable.
  // Collected only when WIFI_IS_UNUSABLE_EVENT_METRICS_ENABLED Settings is enabled.
  repeated WifiIsUnusableEvent wifi_is_unusable_event_list = 120;

  // Counts the occurrences of each link speed (Mbps) level
  // with rssi (dBm) and rssi^2 sums (dBm^2)
  repeated LinkSpeedCount link_speed_counts = 121;

  // Number of times the SarManager failed to register SAR sensor listener
  optional int32 num_sar_sensor_registration_failures = 122;

  // Hardware revision (EVT, DVT, PVT etc.)
  optional string hardware_revision = 124;

  // Total wifi link layer usage data over the logging duration in ms.
  optional WifiLinkLayerUsageStats wifi_link_layer_usage_stats = 125;

  // Multiple lists of timestamped link layer stats with labels to represent whether wifi is usable
  repeated WifiUsabilityStats wifi_usability_stats_list = 126;

  // Counts the occurrences of each Wifi usability score provided by external app
  repeated WifiUsabilityScoreCount wifi_usability_score_count = 127;

  // List of PNO scan stats, one element for each mobility state
  repeated DeviceMobilityStatePnoScanStats mobility_state_pno_stats_list = 128;

  // Wifi p2p statistics
  optional WifiP2pStats wifi_p2p_stats = 129;

  // Easy Connect (DPP) metrics
  optional WifiDppLog wifi_dpp_log = 130;

  // Number of Enhanced Open (OWE) networks in the saved networks.
  optional int32 num_enhanced_open_networks = 131;

  // Number of WPA3-Personal networks.
  optional int32 num_wpa3_personal_networks = 132;

  // Number of WPA3-Enterprise networks.
  optional int32 num_wpa3_enterprise_networks = 133;

  // Total number of scan results for Enhanced open networks
  optional int32 num_enhanced_open_network_scan_results = 134;

  // Total number of scan results for WPA3-Personal networks
  optional int32 num_wpa3_personal_network_scan_results = 135;

  // Total number of scan results for WPA3-Enterprise networks
  optional int32 num_wpa3_enterprise_network_scan_results = 136;

  // WifiConfigStore read/write metrics.
  optional WifiConfigStoreIO wifi_config_store_io = 137;

  // Total number of saved networks with mac randomization enabled.
  optional int32 num_saved_networks_with_mac_randomization = 138;

  // Link Probe metrics
  optional LinkProbeStats link_probe_stats = 139;

  // List of NetworkSelectionExperimentDecisions stats for each experiment
  repeated NetworkSelectionExperimentDecisions network_selection_experiment_decisions_list = 140;

  // Network Request API surface metrics.
  optional WifiNetworkRequestApiLog wifi_network_request_api_log = 141;

  // Network Suggestion API surface metrics.
  optional WifiNetworkSuggestionApiLog wifi_network_suggestion_api_log = 142;

  // WifiLock statistics
  optional WifiLockStats wifi_lock_stats = 143;

  // Stats on number of times Wi-Fi is turned on/off though the WifiManager#setWifiEnabled API
  optional WifiToggleStats wifi_toggle_stats = 144;

  // Number of times WifiManager#addOrUpdateNetwork is called.
  optional int32 num_add_or_update_network_calls = 145;

  // Number of times WifiManager#enableNetwork is called.
  optional int32 num_enable_network_calls = 146;

  // Passpoint provison metrics
  optional PasspointProvisionStats passpoint_provision_stats = 147;

  // Histogram of the EAP method type of all installed Passpoint profiles for R1
  repeated PasspointProfileTypeCount installed_passpoint_profile_type_for_r1 = 123;

  // Histogram of the EAP method type of all installed Passpoint profiles for R2
  repeated PasspointProfileTypeCount installed_passpoint_profile_type_for_r2 = 148;

  // Histogram of Tx link speed at 2G
  repeated Int32Count tx_link_speed_count_2g = 149;

  // Histogram of Tx link speed at 5G low band
  repeated Int32Count tx_link_speed_count_5g_low = 150;

  // Histogram of Tx link speed at 5G middle band
  repeated Int32Count tx_link_speed_count_5g_mid = 151;

  // Histogram of Tx link speed at 5G high band
  repeated Int32Count tx_link_speed_count_5g_high = 152;

  // Histogram of Rx link speed at 2G
  repeated Int32Count rx_link_speed_count_2g = 153;

  // Histogram of Rx link speed at 5G low band
  repeated Int32Count rx_link_speed_count_5g_low = 154;

  // Histogram of Rx link speed at 5G middle band
  repeated Int32Count rx_link_speed_count_5g_mid = 155;

  // Histogram of Rx link speed at 5G high band
  repeated Int32Count rx_link_speed_count_5g_high = 156;
}

// Information that gets logged for every WiFi connection.
message RouterFingerPrint {

  enum RoamType {

    // Type is unknown.
    ROAM_TYPE_UNKNOWN = 0;

    // No roaming - usually happens on a single band (2.4 GHz) router.
    ROAM_TYPE_NONE = 1;

    // Enterprise router.
    ROAM_TYPE_ENTERPRISE = 2;

    // DBDC => Dual Band Dual Concurrent essentially a router that
    // supports both 2.4 GHz and 5 GHz bands.
    ROAM_TYPE_DBDC = 3;
  }

  enum Auth {

    // Auth is unknown.
    AUTH_UNKNOWN = 0;

    // No authentication.
    AUTH_OPEN = 1;

    // If the router uses a personal authentication.
    AUTH_PERSONAL = 2;

    // If the router is setup for enterprise authentication.
    AUTH_ENTERPRISE = 3;
  }

  enum RouterTechnology {

    // Router is unknown.
    ROUTER_TECH_UNKNOWN = 0;

    // Router Channel A.
    ROUTER_TECH_A = 1;

    // Router Channel B.
    ROUTER_TECH_B = 2;

    // Router Channel G.
    ROUTER_TECH_G = 3;

    // Router Channel N.
    ROUTER_TECH_N = 4;

    // Router Channel AC.
    ROUTER_TECH_AC = 5;

    // When the channel is not one of the above.
    ROUTER_TECH_OTHER = 6;
  }

  optional RoamType roam_type = 1;

  // Channel on which the connection takes place.
  optional int32 channel_info = 2;

  // DTIM setting of the router.
  optional int32 dtim = 3;

  // Authentication scheme of the router.
  optional Auth authentication = 4;

  // If the router is hidden.
  optional bool hidden = 5;

  // Channel information.
  optional RouterTechnology router_technology = 6;

  // whether ipv6 is supported.
  optional bool supports_ipv6 = 7;

  // If the router is a passpoint / hotspot 2.0 network
  optional bool passpoint = 8;
}

message ConnectionEvent {

  // Roam Type.
  enum RoamType {

    // Type is unknown.
    ROAM_UNKNOWN = 0;

    // No roaming.
    ROAM_NONE = 1;

    // DBDC roaming.
    ROAM_DBDC = 2;

    // Enterprise roaming.
    ROAM_ENTERPRISE = 3;

    // User selected roaming.
    ROAM_USER_SELECTED = 4;

    // Unrelated.
    ROAM_UNRELATED = 5;
  }

  // Connectivity Level Failure.
  enum ConnectivityLevelFailure {

    // Failure is unknown.
    HLF_UNKNOWN = 0;

    // No failure.
    HLF_NONE = 1;

    // DHCP failure.
    HLF_DHCP = 2;

    // No internet connection.
    HLF_NO_INTERNET = 3;

    // No internet connection.
    HLF_UNWANTED = 4;
  }

  // Level 2 failure reason.
  enum Level2FailureReason {

    // Unknown default
    FAILURE_REASON_UNKNOWN = 0;

    // The reason code if there is no error during authentication. It could
    // also imply that there no authentication in progress.
    AUTH_FAILURE_NONE = 1;

    // The reason code if there was a timeout authenticating.
    AUTH_FAILURE_TIMEOUT = 2;

    // The reason code if there was a wrong password while authenticating.
    AUTH_FAILURE_WRONG_PSWD = 3;

    // The reason code if there was EAP failure while authenticating.
    AUTH_FAILURE_EAP_FAILURE = 4;
  }

  // Entity that recommended connecting to this network.
  enum ConnectionNominator {
    // Unknown nominator
    NOMINATOR_UNKNOWN = 0;

    // User selected network manually
    NOMINATOR_MANUAL = 1;

    // Saved network
    NOMINATOR_SAVED = 2;

    // Suggestion API
    NOMINATOR_SUGGESTION = 3;

    // Passpoint
    NOMINATOR_PASSPOINT = 4;

    // Carrier suggestion
    NOMINATOR_CARRIER = 5;

    // External scorer
    NOMINATOR_EXTERNAL_SCORED = 6;

    // Network Specifier
    NOMINATOR_SPECIFIER = 7;

    // User connected choice override
    NOMINATOR_SAVED_USER_CONNECT_CHOICE = 8;

    // Open Network Available Pop-up
    NOMINATOR_OPEN_NETWORK_AVAILABLE = 9;
  }

  // Start time of the connection.
  optional int64 start_time_millis = 1;// [(datapol.semantic_type) = ST_TIMESTAMP];

  // Duration to connect.
  optional int32 duration_taken_to_connect_millis = 2;

  // Router information.
  optional RouterFingerPrint router_fingerprint = 3;

  // RSSI at the start of the connection.
  optional int32 signal_strength = 4;

  // Roam Type.
  optional RoamType roam_type = 5;

  // Result of the connection.
  optional int32 connection_result = 6;

  // Reasons for level 2 failure (needs to be coordinated with wpa-supplicant).
  optional int32 level_2_failure_code = 7;

  // Failures that happen at the connectivity layer.
  optional ConnectivityLevelFailure connectivity_level_failure_code = 8;

  // Has bug report been taken.
  optional bool automatic_bug_report_taken = 9;

  // Connection is using locally generated random MAC address.
  optional bool use_randomized_mac = 10 [default = false];

  // Who chose to connect.
  optional ConnectionNominator connection_nominator = 11;

  // The currently running network selector when this connection event occurred.
  optional int32 network_selector_experiment_id = 12;

  // Breakdown of level_2_failure_code with more detailed reason.
  optional Level2FailureReason level_2_failure_reason = 13
          [default = FAILURE_REASON_UNKNOWN];
}

// Number of occurrences of a specific RSSI poll rssi value
message RssiPollCount {
  // RSSI
  optional int32 rssi = 1;

  // Number of RSSI polls with 'rssi'
  optional int32 count = 2;

  // Beacon frequency of the channel in MHz
  optional int32 frequency = 3;
}

// Number of occurrences of a specific alert reason value
message AlertReasonCount {
  // Alert reason
  optional int32 reason = 1;

  // Number of alerts with |reason|.
  optional int32 count = 2;
}

// Counts the number of instances of a specific Wifi Score calculated by WifiScoreReport
message WifiScoreCount {
  // Wifi Score
  optional int32 score = 1;

  // Number of Wifi score reports with this score
  optional int32 count = 2;
}

// Counts the number of instances of a specific Wifi Usability Score
message WifiUsabilityScoreCount {
  // Wifi Usability Score
  optional int32 score = 1;

  // Number of Wifi score reports with this score
  optional int32 count = 2;
}

// Number of occurrences of a specific link speed (Mbps)
// and sum of rssi (dBm) and rssi^2 (dBm^2)
message LinkSpeedCount {
  // Link speed (Mbps)
  optional int32 link_speed_mbps = 1;

  // Number of RSSI polls with link_speed
  optional int32 count = 2;

  // Sum of absolute values of rssi values (dBm)
  optional int32 rssi_sum_dbm = 3;

  // Sum of squares of rssi values (dBm^2)
  optional int64 rssi_sum_of_squares_dbm_sq = 4;
}


// Number of occurrences of Soft AP session durations
message SoftApDurationBucket {
  // Bucket covers duration : [duration_sec, duration_sec + bucket_size_sec)
  // The (inclusive) lower bound of Soft AP session duration represented by this bucket
  optional int32 duration_sec = 1;

  // The size of this bucket
  optional int32 bucket_size_sec = 2;

  // Number of soft AP session durations that fit into this bucket
  optional int32 count = 3;
}

// Number of occurrences of a soft AP session return code
message SoftApReturnCodeCount {

  enum SoftApStartResult {

    // SoftApManager return code unknown
    SOFT_AP_RETURN_CODE_UNKNOWN = 0;

    // SoftAp started successfully
    SOFT_AP_STARTED_SUCCESSFULLY = 1;

    // Catch all for failures with no specific failure reason
    SOFT_AP_FAILED_GENERAL_ERROR = 2;

    // SoftAp failed to start due to NO_CHANNEL error
    SOFT_AP_FAILED_NO_CHANNEL = 3;
  }

  // Historical, no longer used for writing as of 01/2017.
  optional int32 return_code = 1 [deprecated = true];

  // Occurrences of this soft AP return code
  optional int32 count = 2;

  // Result of attempt to start SoftAp
  optional SoftApStartResult start_result = 3;
}

message StaEvent {
  message ConfigInfo {
    // The set of key management protocols supported by this configuration.
    optional uint32 allowed_key_management = 1 [default = 0];

    // The set of security protocols supported by this configuration.
    optional uint32 allowed_protocols = 2 [default = 0];

    // The set of authentication protocols supported by this configuration.
    optional uint32 allowed_auth_algorithms = 3 [default = 0];

    // The set of pairwise ciphers for WPA supported by this configuration.
    optional uint32 allowed_pairwise_ciphers = 4 [default = 0];

    // The set of group ciphers supported by this configuration.
    optional uint32 allowed_group_ciphers = 5;

    // Is this a 'hidden network'
    optional bool hidden_ssid = 6;

    // Is this a Hotspot 2.0 / passpoint network
    optional bool is_passpoint = 7;

    // Is this an 'ephemeral' network (Not in saved network list, recommended externally)
    optional bool is_ephemeral = 8;

    // Has a successful connection ever been established using this WifiConfiguration
    optional bool has_ever_connected = 9;

    // RSSI of the scan result candidate associated with this WifiConfiguration
    optional int32 scan_rssi = 10 [default = -127];

    // Frequency of the scan result candidate associated with this WifiConfiguration
    optional int32 scan_freq = 11 [default = -1];
  }

  enum EventType {
    // Default/Invalid event
    TYPE_UNKNOWN = 0;

    // Supplicant Association Rejection event. Code contains the 802.11
    TYPE_ASSOCIATION_REJECTION_EVENT = 1;

    // Supplicant L2 event,
    TYPE_AUTHENTICATION_FAILURE_EVENT = 2;

    // Supplicant L2 event
    TYPE_NETWORK_CONNECTION_EVENT = 3;

    // Supplicant L2 event
    TYPE_NETWORK_DISCONNECTION_EVENT = 4;

    // Supplicant L2 event
    TYPE_SUPPLICANT_STATE_CHANGE_EVENT = 5;

    // Supplicant L2 event
    TYPE_CMD_ASSOCIATED_BSSID = 6;

    // IP Manager successfully completed IP Provisioning
    TYPE_CMD_IP_CONFIGURATION_SUCCESSFUL = 7;

    // IP Manager failed to complete IP Provisioning
    TYPE_CMD_IP_CONFIGURATION_LOST = 8;

    // IP Manager lost reachability to network neighbors
    TYPE_CMD_IP_REACHABILITY_LOST = 9;

    // Indicator that Supplicant is targeting a BSSID for roam/connection
    TYPE_CMD_TARGET_BSSID = 10;

    // Wifi framework is initiating a connection attempt
    TYPE_CMD_START_CONNECT = 11;

    // Wifi framework is initiating a roaming connection attempt
    TYPE_CMD_START_ROAM = 12;

    // SystemAPI connect() command, Settings App
    TYPE_CONNECT_NETWORK = 13;

    // Network Agent has validated the internet connection (Captive Portal Check success, or user
    // validation)
    TYPE_NETWORK_AGENT_VALID_NETWORK = 14;

    // Framework initiated disconnect. Sometimes generated to give an extra reason for a disconnect
    // Should typically be followed by a NETWORK_DISCONNECTION_EVENT with a local_gen = true
    TYPE_FRAMEWORK_DISCONNECT = 15;

    // The NetworkAgent score for wifi has changed in a way that may impact
    // connectivity
    TYPE_SCORE_BREACH = 16;

    // Framework changed Sta interface MAC address
    TYPE_MAC_CHANGE = 17;

    // Wifi is turned on
    TYPE_WIFI_ENABLED = 18;

    // Wifi is turned off
    TYPE_WIFI_DISABLED = 19;

    // The NetworkAgent Wifi usability score has changed in a way that may
    // impact connectivity
    TYPE_WIFI_USABILITY_SCORE_BREACH = 20;

    // Link probe was performed
    TYPE_LINK_PROBE = 21;
  }

  enum FrameworkDisconnectReason {
    // default/none/unknown value
    DISCONNECT_UNKNOWN = 0;

    // API DISCONNECT
    DISCONNECT_API = 1;

    // Some framework internal reason (generic)
    DISCONNECT_GENERIC = 2;

    // Network Agent network validation failed, user signaled network unwanted
    DISCONNECT_UNWANTED = 3;

    // Roaming timed out
    DISCONNECT_ROAM_WATCHDOG_TIMER = 4;

    // P2P service requested wifi disconnect
    DISCONNECT_P2P_DISCONNECT_WIFI_REQUEST = 5;

    // SIM was removed while using a SIM config
    DISCONNECT_RESET_SIM_NETWORKS = 6;
  }

  // Authentication Failure reasons as reported through the API.
  enum AuthFailureReason {
    // Unknown default
    AUTH_FAILURE_UNKNOWN = 0;

    // The reason code if there is no error during authentication. It could also imply that there no
    // authentication in progress,
    AUTH_FAILURE_NONE = 1;

    // The reason code if there was a timeout authenticating.
    AUTH_FAILURE_TIMEOUT = 2;

    // The reason code if there was a wrong password while authenticating.
    AUTH_FAILURE_WRONG_PSWD = 3;

    // The reason code if there was EAP failure while authenticating.
    AUTH_FAILURE_EAP_FAILURE = 4;
  }

  // What event was this
  optional EventType type = 1;

  // 80211 death reason code, relevant to NETWORK_DISCONNECTION_EVENTs
  optional int32 reason = 2 [default = -1];

  // 80211 Association Status code, relevant to ASSOCIATION_REJECTION_EVENTs
  optional int32 status = 3 [default = -1];

  // Designates whether a NETWORK_DISCONNECT_EVENT was by the STA or AP
  optional bool local_gen = 4 [default = false];

  // Network information from the WifiConfiguration of a framework initiated connection attempt
  optional ConfigInfo config_info = 5;

  // RSSI from the last rssi poll (Only valid for active connections)
  optional int32 last_rssi = 6 [default = -127];

  // Link speed from the last rssi poll (Only valid for active connections)
  optional int32 last_link_speed = 7 [default = -1];

  // Frequency from the last rssi poll (Only valid for active connections)
  optional int32 last_freq = 8 [default = -1];

  // Enum used to define bit positions in the supplicant_state_change_bitmask
  // See {@code frameworks/base/wifi/java/android/net/wifi/SupplicantState.java} for documentation
  enum SupplicantState {
    STATE_DISCONNECTED = 0;

    STATE_INTERFACE_DISABLED = 1;

    STATE_INACTIVE = 2;

    STATE_SCANNING = 3;

    STATE_AUTHENTICATING = 4;

    STATE_ASSOCIATING = 5;

    STATE_ASSOCIATED = 6;

    STATE_FOUR_WAY_HANDSHAKE = 7;

    STATE_GROUP_HANDSHAKE = 8;

    STATE_COMPLETED = 9;

    STATE_DORMANT = 10;

    STATE_UNINITIALIZED = 11;

    STATE_INVALID = 12;
  }

  // Bit mask of all supplicant state changes that occurred since the last event
  optional uint32 supplicant_state_changes_bitmask = 9 [default = 0];

  // The number of milliseconds that have elapsed since the device booted
  optional int64 start_time_millis = 10 [default = 0];

  optional FrameworkDisconnectReason framework_disconnect_reason = 11 [default = DISCONNECT_UNKNOWN];

  // Flag which indicates if an association rejection event occurred due to a timeout
  optional bool association_timed_out = 12 [default = false];

  // Authentication failure reason, as reported by WifiManager (calculated from state & deauth code)
  optional AuthFailureReason auth_failure_reason = 13 [default = AUTH_FAILURE_UNKNOWN];

  // NetworkAgent score of connected wifi
  optional int32 last_score = 14 [default = -1];

  // NetworkAgent Wifi usability score of connected wifi
  optional int32 last_wifi_usability_score = 15 [default = -1];

  // Prediction horizon (in second) of Wifi usability score provided by external
  // system app
  optional int32 last_prediction_horizon_sec = 16 [default = -1];

  // Only valid if event type == TYPE_LINK_PROBE.
  // true if link probe succeeded, false otherwise.
  optional bool link_probe_was_success = 17;

  // Only valid if event type == TYPE_LINK_PROBE and link_probe_was_success == true.
  // Elapsed time, in milliseconds, of a successful link probe.
  optional int32 link_probe_success_elapsed_time_ms = 18;

  // Only valid if event type == TYPE_LINK_PROBE and link_probe_was_success == false.
  // Failure reason for an unsuccessful link probe.
  optional LinkProbeStats.LinkProbeFailureReason link_probe_failure_reason = 19;
}

// Wi-Fi Aware metrics
message WifiAwareLog {
  // total number of unique apps that used Aware (measured on attach)
  optional int32 num_apps = 1;

  // total number of unique apps that used an identity callback when attaching
  optional int32 num_apps_using_identity_callback = 2;

  // maximum number of attaches for an app
  optional int32 max_concurrent_attach_sessions_in_app = 3;

  // histogram of attach request results
  repeated NanStatusHistogramBucket histogram_attach_session_status = 4;

  // maximum number of concurrent publish sessions in a single app
  optional int32 max_concurrent_publish_in_app = 5;

  // maximum number of concurrent subscribe sessions in a single app
  optional int32 max_concurrent_subscribe_in_app = 6;

  // maximum number of concurrent discovery (publish+subscribe) sessions in a single app
  optional int32 max_concurrent_discovery_sessions_in_app = 7;

  // maximum number of concurrent publish sessions in the system
  optional int32 max_concurrent_publish_in_system = 8;

  // maximum number of concurrent subscribe sessions in the system
  optional int32 max_concurrent_subscribe_in_system = 9;

  // maximum number of concurrent discovery (publish+subscribe) sessions in the system
  optional int32 max_concurrent_discovery_sessions_in_system = 10;

  // histogram of publish request results
  repeated NanStatusHistogramBucket histogram_publish_status = 11;

  // histogram of subscribe request results
  repeated NanStatusHistogramBucket histogram_subscribe_status = 12;

  // number of unique apps which experienced a discovery session creation failure due to lack of
  // resources
  optional int32 num_apps_with_discovery_session_failure_out_of_resources = 13;

  // histogram of create ndp request results
  repeated NanStatusHistogramBucket histogram_request_ndp_status = 14;

  // histogram of create ndp out-of-band (OOB) request results
  repeated NanStatusHistogramBucket histogram_request_ndp_oob_status = 15;

  // maximum number of concurrent active data-interfaces (NDI) in a single app
  optional int32 max_concurrent_ndi_in_app = 19;

  // maximum number of concurrent active data-interfaces (NDI) in the system
  optional int32 max_concurrent_ndi_in_system = 20;

  // maximum number of concurrent data-paths (NDP) in a single app
  optional int32 max_concurrent_ndp_in_app = 21;

  // maximum number of concurrent data-paths (NDP) in the system
  optional int32 max_concurrent_ndp_in_system = 22;

  // maximum number of concurrent secure data-paths (NDP) in a single app
  optional int32 max_concurrent_secure_ndp_in_app = 23;

  // maximum number of concurrent secure data-paths (NDP) in the system
  optional int32 max_concurrent_secure_ndp_in_system = 24;

  // maximum number of concurrent data-paths (NDP) per data-interface (NDI)
  optional int32 max_concurrent_ndp_per_ndi = 25;

  // histogram of durations of Aware being available
  repeated HistogramBucket histogram_aware_available_duration_ms = 26;

  // histogram of durations of Aware being enabled
  repeated HistogramBucket histogram_aware_enabled_duration_ms = 27;

  // histogram of duration (in ms) of attach sessions
  repeated HistogramBucket histogram_attach_duration_ms = 28;

  // histogram of duration (in ms) of publish sessions
  repeated HistogramBucket histogram_publish_session_duration_ms = 29;

  // histogram of duration (in ms) of subscribe sessions
  repeated HistogramBucket histogram_subscribe_session_duration_ms = 30;

  // histogram of duration (in ms) of data-paths (NDP)
  repeated HistogramBucket histogram_ndp_session_duration_ms = 31;

  // histogram of usage (in MB) of data-paths (NDP)
  repeated HistogramBucket histogram_ndp_session_data_usage_mb = 32;

  // histogram of usage (in MB) of data-path creation time (in ms) measured as request -> confirm
  repeated HistogramBucket histogram_ndp_creation_time_ms = 33;

  // statistics for data-path (NDP) creation time (in ms) measured as request -> confirm: minimum
  optional int64 ndp_creation_time_ms_min = 34;

  // statistics for data-path (NDP) creation time (in ms) measured as request -> confirm: maximum
  optional int64 ndp_creation_time_ms_max = 35;

  // statistics for data-path (NDP) creation time (in ms) measured as request -> confirm: sum
  optional int64 ndp_creation_time_ms_sum = 36;

  // statistics for data-path (NDP) creation time (in ms) measured as request -> confirm: sum of sq
  optional int64 ndp_creation_time_ms_sum_of_sq = 37;

  // statistics for data-path (NDP) creation time (in ms) measured as request -> confirm: number of
  // samples
  optional int64 ndp_creation_time_ms_num_samples = 38;

  // total time within the logging window that aware was available
  optional int64 available_time_ms = 39;

  // total time within the logging window that aware was enabled
  optional int64 enabled_time_ms = 40;

  // maximum number of concurrent publish sessions enabling ranging in a single app
  optional int32 max_concurrent_publish_with_ranging_in_app = 41;

  // maximum number of concurrent subscribe sessions specifying a geofence in a single app
  optional int32 max_concurrent_subscribe_with_ranging_in_app = 42;

  // maximum number of concurrent publish sessions enabling ranging in the system
  optional int32 max_concurrent_publish_with_ranging_in_system = 43;

  // maximum number of concurrent subscribe sessions specifying a geofence in the system
  optional int32 max_concurrent_subscribe_with_ranging_in_system = 44;

  // histogram of subscribe session geofence minimum (only when specified)
  repeated HistogramBucket histogram_subscribe_geofence_min = 45;

  // histogram of subscribe session geofence maximum (only when specified)
  repeated HistogramBucket histogram_subscribe_geofence_max = 46;

  // total number of subscribe sessions which enabled ranging
  optional int32 num_subscribes_with_ranging = 47;

  // total number of matches (service discovery indication) with ranging provided
  optional int32 num_matches_with_ranging = 48;

  // total number of matches (service discovery indication) for service discovery with ranging
  // enabled which did not trigger ranging
  optional int32 num_matches_without_ranging_for_ranging_enabled_subscribes = 49;

  // Histogram bucket for Wi-Fi Aware logs. Range is [start, end)
  message HistogramBucket {
    // lower range of the bucket (inclusive)
    optional int64 start = 1;

    // upper range of the bucket (exclusive)
    optional int64 end = 2;

    // number of samples in the bucket
    optional int32 count = 3;
  }

  // Status of various NAN operations
  enum NanStatusTypeEnum {
    // constant to be used by proto
    UNKNOWN = 0;

    // NAN operation succeeded
    SUCCESS = 1;

    // NAN Discovery Engine/Host driver failures
    INTERNAL_FAILURE = 2;

    // NAN OTA failures
    PROTOCOL_FAILURE = 3;

    // The publish/subscribe discovery session id is invalid
    INVALID_SESSION_ID = 4;

    // Out of resources to fufill request
    NO_RESOURCES_AVAILABLE = 5;

    // Invalid arguments passed
    INVALID_ARGS = 6;

    // Invalid peer id
    INVALID_PEER_ID = 7;

    // Invalid NAN data-path (ndp) id
    INVALID_NDP_ID = 8;

    // Attempting to enable NAN when not available, e.g. wifi is disabled
    NAN_NOT_ALLOWED = 9;

    // Over the air ACK not received
    NO_OTA_ACK = 10;

    // Attempting to enable NAN when already enabled
    ALREADY_ENABLED = 11;

    // Can't queue tx followup message foor transmission
    FOLLOWUP_TX_QUEUE_FULL = 12;

    // Unsupported concurrency of NAN and another feature - NAN disabled
    UNSUPPORTED_CONCURRENCY_NAN_DISABLED = 13;

    // Unknown NanStatusType
    UNKNOWN_HAL_STATUS = 14;
  }

  // Histogram bucket for Wi-Fi Aware (NAN) status.
  message NanStatusHistogramBucket {
    // status type defining the bucket
    optional NanStatusTypeEnum nan_status_type = 1;

    // number of samples in the bucket
    optional int32 count = 2;
  }
}

// Data point used to build 'Number of Connectable Network' histograms
message NumConnectableNetworksBucket {
  // Number of connectable networks seen in a scan result
  optional int32 num_connectable_networks = 1 [default = 0];

  // Number of scan results with num_connectable_networks
  optional int32 count = 2 [default = 0];
}

// Pno scan metrics
// Here "Pno Scan" refers to the session of offloaded scans, these metrics count the result of a
// single session, and not the individual scans within that session.
message PnoScanMetrics {
  // Total number of attempts to offload pno scans
  optional int32 num_pno_scan_attempts = 1;

  // Total number of pno scans failed
  optional int32 num_pno_scan_failed = 2;

  // Number of pno scans started successfully over offload
  optional int32 num_pno_scan_started_over_offload = 3;

  // Number of pno scans failed over offload
  optional int32 num_pno_scan_failed_over_offload = 4;

  // Total number of pno scans that found any network
  optional int32 num_pno_found_network_events = 5;
}

// Number of occurrences for a particular "Connect to Network" Notification or
// notification Action.
message ConnectToNetworkNotificationAndActionCount {

  // "Connect to Network" notifications
  enum Notification {

    // Default
    NOTIFICATION_UNKNOWN = 0;

    // Initial notification with a recommended network.
    NOTIFICATION_RECOMMEND_NETWORK = 1;

    // Notification when connecting to the recommended network.
    NOTIFICATION_CONNECTING_TO_NETWORK = 2;

    // Notification when successfully connected to the network.
    NOTIFICATION_CONNECTED_TO_NETWORK = 3;

    // Notification when failed to connect to network.
    NOTIFICATION_FAILED_TO_CONNECT = 4;
  }

  // "Connect to Network" notification actions
  enum Action {

    // Default
    ACTION_UNKNOWN = 0;

    // User dismissed the "Connect to Network" notification.
    ACTION_USER_DISMISSED_NOTIFICATION = 1;

    // User tapped action button to connect to recommended network.
    ACTION_CONNECT_TO_NETWORK = 2;

    // User tapped action button to open Wi-Fi Settings.
    ACTION_PICK_WIFI_NETWORK = 3;

    // User tapped "Failed to connect" notification to open Wi-Fi Settings.
    ACTION_PICK_WIFI_NETWORK_AFTER_CONNECT_FAILURE = 4;
  }

  // Recommenders of the "Connect to Network" notification
  enum Recommender {

    // Default.
    RECOMMENDER_UNKNOWN = 0;

    // Open Network Available recommender.
    RECOMMENDER_OPEN = 1;
  }

  // Notification Type.
  optional Notification notification = 1;

  // Action Type.
  optional Action action = 2;

  // Recommender Type.
  optional Recommender recommender = 3;

  // Occurrences of this action.
  optional int32 count = 4;
}

// SoftAP event tracking sessions and client counts
message SoftApConnectedClientsEvent {

  // Soft AP event Types
  enum SoftApEventType {

    // Soft AP is Up and ready for use
    SOFT_AP_UP = 0;

    // Soft AP is Down
    SOFT_AP_DOWN = 1;

    // Number of connected soft AP clients has changed
    NUM_CLIENTS_CHANGED = 2;
  }

  // Soft AP channel bandwidth types
  enum ChannelBandwidth {

    BANDWIDTH_INVALID = 0;

    BANDWIDTH_20_NOHT = 1;

    BANDWIDTH_20 = 2;

    BANDWIDTH_40 = 3;

    BANDWIDTH_80 = 4;

    BANDWIDTH_80P80 = 5;

    BANDWIDTH_160 = 6;
  }

  // Type of event being recorded
  optional SoftApEventType event_type = 1;

  // Time passed since last boot in milliseconds
  optional int64 time_stamp_millis = 2;

  // Number of connected clients if event_type is NUM_CLIENTS_CHANGED, otherwise zero.
  optional int32 num_connected_clients = 3;

  // Channel frequency used for Soft AP
  optional int32 channel_frequency = 4;

  // Channel bandwidth used for Soft AP
  optional ChannelBandwidth channel_bandwidth = 5;
}

// Wps connection metrics
// Keeps track of Wi-Fi Protected Setup usage
message WpsMetrics {
  // Total number of wps connection attempts
  optional int32 num_wps_attempts = 1;

  // Total number of wps connection successes
  optional int32 num_wps_success = 2;

  // Total number of wps failures on start
  optional int32 num_wps_start_failure = 3;

  // Total number of wps overlap failure
  optional int32 num_wps_overlap_failure = 4;

  // Total number of wps timeout failure
  optional int32 num_wps_timeout_failure = 5;

  // Total number of other wps failure during connection
  optional int32 num_wps_other_connection_failure = 6;

  // Total number of supplicant failure after wps
  optional int32 num_wps_supplicant_failure = 7;

  // Total number of wps cancellation
  optional int32 num_wps_cancellation = 8;
}

// Power stats for Wifi
message WifiPowerStats {

  // Duration of log (ms)
  optional int64 logging_duration_ms = 1;

  // Energy consumed by wifi (mAh)
  optional double energy_consumed_mah = 2;

  // Amount of time wifi is in idle (ms)
  optional int64 idle_time_ms = 3;

  // Amount of time wifi is in rx (ms)
  optional int64 rx_time_ms = 4;

  // Amount of time wifi is in tx (ms)
  optional int64 tx_time_ms = 5;

  // Amount of time kernel is active because of wifi data (ms)
  optional int64 wifi_kernel_active_time_ms = 6;

  // Number of packets sent (tx)
  optional int64 num_packets_tx = 7;

  // Number of bytes sent (tx)
  optional int64 num_bytes_tx = 8;

  // Number of packets received (rx)
  optional int64 num_packets_rx = 9;

  // Number of bytes sent (rx)
  optional int64 num_bytes_rx = 10;

  // Amount of time wifi is in sleep (ms)
  optional int64 sleep_time_ms = 11;

  // Amount of time wifi is scanning (ms)
  optional int64 scan_time_ms = 12;

  // Actual monitored rail energy consumed by wifi (mAh)
  optional double monitored_rail_energy_consumed_mah = 13;
}

// Metrics for Wifi Wake
message WifiWakeStats {
  // An individual session for Wifi Wake
  message Session {
    // A Wifi Wake lifecycle event
    message Event {
      // Elapsed time in milliseconds since start of session.
      optional int64 elapsed_time_millis = 1;

      // Number of scans that have occurred since start of session.
      optional int32 elapsed_scans = 2;
    }

    // Start time of session in milliseconds.
    optional int64 start_time_millis = 1;

    // The number of networks the lock was provided with at start.
    optional int32 locked_networks_at_start = 2;

    // The number of networks in the lock at the time of the initialize event. Only valid if
    // initialize_event is recorded.
    optional int32 locked_networks_at_initialize = 6;

    // Event for fully initializing the WakeupLock (i.e. WakeupLock is "locked").
    optional Event initialize_event = 7;

    // Event for unlocking the WakeupLock. Does not occur if lock was initialized with 0 networks.
    optional Event unlock_event = 3;

    // Event for triggering wakeup.
    optional Event wakeup_event = 4;

    // Event for WifiWake reset event. This event marks the end of a session.
    optional Event reset_event = 5;
  }

  // Total number of sessions for Wifi Wake.
  optional int32 num_sessions = 1;

  // Session information for every Wifi Wake session (up to a maximum of 10).
  repeated Session sessions = 2;

  // Number of ignored calls to start (due to WakeupController already being active).
  optional int32 num_ignored_starts = 3;

  // Number of Wifi Wake sessions that have recorded wakeup events.
  optional int32 num_wakeups = 4;
}

// Metrics for Wi-Fi RTT
message WifiRttLog {
  // Number of RTT request API calls
  optional int32 num_requests = 1;

  // Histogram of RTT operation overall status
  repeated RttOverallStatusHistogramBucket histogram_overall_status = 2;

  // RTT to Access Points metrics
  optional RttToPeerLog rtt_to_ap = 3;

  // RTT to Wi-Fi Aware peers metrics
  optional RttToPeerLog rtt_to_aware = 4;

  // Metrics for a RTT to Peer (peer = AP or Wi-Fi Aware)
  message RttToPeerLog {
    // Total number of API calls
    optional int32 num_requests = 1;

    // Total number of individual requests
    optional int32 num_individual_requests = 2;

    // Total number of apps which requested RTT
    optional int32 num_apps = 3;

    // Histogram of total number of RTT requests by an app (WifiRttManager#startRanging)
    repeated HistogramBucket histogram_num_requests_per_app = 4;

    // Histogram of number of peers in a single RTT request (RangingRequest entries)
    repeated HistogramBucket histogram_num_peers_per_request = 5;

    // Histogram of status of individual RTT operations (RangingResult entries)
    repeated RttIndividualStatusHistogramBucket histogram_individual_status = 6;

    // Histogram of measured distances (RangingResult entries)
    repeated HistogramBucket histogram_distance = 7;

    // Histogram of interval of RTT requests by an app (WifiRttManager#startRanging)
    repeated HistogramBucket histogram_request_interval_ms = 8;
  }

  // Histogram bucket for Wi-Fi RTT logs. Range is [start, end)
  message HistogramBucket {
    // lower range of the bucket (inclusive)
    optional int64 start = 1;

    // upper range of the bucket (exclusive)
    optional int64 end = 2;

    // number of samples in the bucket
    optional int32 count = 3;
  }

  // Status codes for overall RTT operation
  enum RttOverallStatusTypeEnum {
    // constant to be used by proto
    OVERALL_UNKNOWN = 0;

    // RTT operation succeeded (individual results may still fail)
    OVERALL_SUCCESS = 1;

    // RTT operation failed (unspecified reason)
    OVERALL_FAIL = 2;

    // RTT operation failed since RTT was not available (e.g. Airplane mode)
    OVERALL_RTT_NOT_AVAILABLE = 3;

    // RTT operation timed-out: didn't receive response from HAL in expected time
    OVERALL_TIMEOUT = 4;

    // RTT operation aborted since the app is spamming the service
    OVERALL_THROTTLE = 5;

    // RTT request to HAL received immediate failure
    OVERALL_HAL_FAILURE = 6;

    // RTT to Wi-Fi Aware peer using PeerHandle failed to get a MAC address translation
    OVERALL_AWARE_TRANSLATION_FAILURE = 7;

    // RTT operation failed due to missing Location permission (post execution)
    OVERALL_LOCATION_PERMISSION_MISSING = 8;
  }

  // Status codes for individual RTT operation
  enum RttIndividualStatusTypeEnum {
    // constant to be used by proto
    UNKNOWN = 0;

    // RTT operation succeeded
    SUCCESS = 1;

    // RTT failure: generic reason (no further information)
    FAILURE = 2;

    // Target STA does not respond to request
    FAIL_NO_RSP = 3;

    // Request rejected. Applies to 2-sided RTT only
    FAIL_REJECTED = 4;

    // Operation not scheduled
    FAIL_NOT_SCHEDULED_YET = 5;

    // Timing measurement times out
    FAIL_TM_TIMEOUT = 6;

    // Target on different channel, cannot range
    FAIL_AP_ON_DIFF_CHANNEL = 7;

    // Ranging not supported
    FAIL_NO_CAPABILITY = 8;

    // Request aborted for unknown reason
    ABORTED = 9;

    // Invalid T1-T4 timestamp
    FAIL_INVALID_TS = 10;

    // 11mc protocol failed
    FAIL_PROTOCOL = 11;

    // Request could not be scheduled
    FAIL_SCHEDULE = 12;

    // Responder cannot collaborate at time of request
    FAIL_BUSY_TRY_LATER = 13;

    // Bad request args
    INVALID_REQ = 14;

    // WiFi not enabled
    NO_WIFI = 15;

    // Responder overrides param info, cannot range with new params
    FAIL_FTM_PARAM_OVERRIDE = 16;

    // HAL did not provide a result to a framework request
    MISSING_RESULT = 17;
  }

  // Histogram bucket for Wi-Fi RTT overall operation status
  message RttOverallStatusHistogramBucket {
    // status type defining the bucket
    optional RttOverallStatusTypeEnum status_type = 1;

    // number of samples in the bucket
    optional int32 count = 2;
  }

  // Histogram bucket for Wi-Fi RTT individual operation status
  message RttIndividualStatusHistogramBucket {
    // status type defining the bucket
    optional RttIndividualStatusTypeEnum status_type = 1;

    // number of samples in the bucket
    optional int32 count = 2;
  }
}

// Usage data for the wifi radio while device is running on battery.
message WifiRadioUsage {
  // Duration of log (ms)
  optional int64 logging_duration_ms = 1;

  // Total time for which the radio is awake due to scan.
  optional int64 scan_time_ms = 2;
}

message ExperimentValues {
  // Indicates if we are logging WifiIsUnusableEvent in metrics
  optional bool wifi_is_unusable_logging_enabled = 1;

  // Minimum number of txBad to trigger a data stall
  optional int32 wifi_data_stall_min_tx_bad = 2;

  // Minimum number of txSuccess to trigger a data stall
  // when rxSuccess is 0
  optional int32 wifi_data_stall_min_tx_success_without_rx = 3;

  // Indicates if we are logging LinkSpeedCount in metrics
  optional bool link_speed_counts_logging_enabled = 4;
}

message WifiIsUnusableEvent {
  enum TriggerType {
    // Default/Invalid event
    TYPE_UNKNOWN = 0;

    // There is a data stall from tx failures
    TYPE_DATA_STALL_BAD_TX = 1;

    // There is a data stall from rx failures
    TYPE_DATA_STALL_TX_WITHOUT_RX = 2;

    // There is a data stall from both tx and rx failures
    TYPE_DATA_STALL_BOTH = 3;

    // Firmware generated an alert
    TYPE_FIRMWARE_ALERT = 4;

    // IP Manager lost reachability to network neighbors
    TYPE_IP_REACHABILITY_LOST = 5;
  }

  // What event triggered WifiIsUnusableEvent.
  optional TriggerType type = 1;

  // The timestamp at which this event occurred.
  // Measured in milliseconds that have elapsed since the device booted.
  optional int64 start_time_millis = 2;

  // NetworkAgent score of connected wifi.
  // Defaults to -1 if the score was never set.
  optional int32 last_score = 3 [default = -1];

  // Delta of successfully transmitted (ACKed) unicast data packets
  // between the last two WifiLinkLayerStats.
  optional int64 tx_success_delta = 4;

  // Delta of transmitted unicast data retry packets
  // between the last two WifiLinkLayerStats.
  optional int64 tx_retries_delta = 5;

  // Delta of lost (not ACKed) transmitted unicast data packets
  // between the last two WifiLinkLayerStats.
  optional int64 tx_bad_delta = 6;

  // Delta of received unicast data packets
  // between the last two WifiLinkLayerStats.
  optional int64 rx_success_delta = 7;

  // Time in millisecond between the last two WifiLinkLayerStats.
  optional int64 packet_update_time_delta = 8;

  // The timestamp at which the last WifiLinkLayerStats was updated.
  // Measured in milliseconds that have elapsed since the device booted.
  optional int64 last_link_layer_stats_update_time = 9;

  // Firmware alert code. Only valid when the event was triggered by a firmware alert, otherwise -1.
  optional int32 firmware_alert_code = 10 [default = -1];

  // NetworkAgent wifi usability score of connected wifi.
  // Defaults to -1 if the score was never set.
  optional int32 last_wifi_usability_score = 11 [default = -1];

  // Prediction horizon (in second) of Wifi usability score provided by external
  // system app
  optional int32 last_prediction_horizon_sec = 12 [default = -1];

  // Whether screen status is on when WifiIsUnusableEvent happens.
  optional bool screen_on = 13 [default = false];
}

message PasspointProfileTypeCount {
  enum EapMethod {
    // Unknown Type
    TYPE_UNKNOWN = 0;

    // EAP_TLS (13)
    TYPE_EAP_TLS = 1;

    // EAP_TTLS (21)
    TYPE_EAP_TTLS = 2;

    // EAP_SIM (18)
    TYPE_EAP_SIM = 3;

    // EAP_AKA (23)
    TYPE_EAP_AKA = 4;

    // EAP_AKA_PRIME (50)
    TYPE_EAP_AKA_PRIME = 5;
  }

  // Eap method type set in Passpoint profile
  optional EapMethod eap_method_type = 1;

  // Num of installed Passpoint profile with same eap method
  optional int32 count = 2;
}

message WifiLinkLayerUsageStats {
  // Total logging duration in ms.
  optional int64 logging_duration_ms = 1;

  // Total time the wifi radio is on in ms over the logging duration.
  optional int64 radio_on_time_ms = 2;

  // Total time the wifi radio is doing tx in ms over the logging duration.
  optional int64 radio_tx_time_ms = 3;

  // Total time the wifi radio is doing rx in ms over the logging duration.
  optional int64 radio_rx_time_ms = 4;

  // Total time the wifi radio is scanning in ms over the logging duration.
  optional int64 radio_scan_time_ms = 5;

  // Total time the wifi radio spent doing nan scans in ms over the logging duration.
  optional int64 radio_nan_scan_time_ms = 6;

  // Total time the wifi radio spent doing background scans in ms over the logging duration.
  optional int64 radio_background_scan_time_ms = 7;

  // Total time the wifi radio spent doing roam scans in ms over the logging duration.
  optional int64 radio_roam_scan_time_ms = 8;

  // Total time the wifi radio spent doing pno scans in ms over the logging duration.
  optional int64 radio_pno_scan_time_ms = 9;

  // Total time the wifi radio spent doing hotspot 2.0 scans and GAS exchange
  // in ms over the logging duration.
  optional int64 radio_hs20_scan_time_ms = 10;
}

message WifiUsabilityStatsEntry {
  // Status codes for link probe status
  enum LinkProbeStatus {
    // Link probe status is unknown
    PROBE_STATUS_UNKNOWN = 0;

    // Link probe is not triggered
    PROBE_STATUS_NO_PROBE = 1;

    // Link probe is triggered and the result is success
    PROBE_STATUS_SUCCESS = 2;

    // Link probe is triggered and the result is failure
    PROBE_STATUS_FAILURE = 3;
  }

  // Codes for cellular data network type
  enum CellularDataNetworkType {
    // Unknown network
    NETWORK_TYPE_UNKNOWN = 0;

    // GSM network
    NETWORK_TYPE_GSM = 1;

    // CDMA network
    NETWORK_TYPE_CDMA = 2;

    // CDMA EVDO network
    NETWORK_TYPE_EVDO_0 = 3;

    // WCDMA network
    NETWORK_TYPE_UMTS = 4;

    // TDSCDMA network
    NETWORK_TYPE_TD_SCDMA = 5;

    // LTE network
    NETWORK_TYPE_LTE = 6;

    // NR network
    NETWORK_TYPE_NR = 7;
  }

  // Absolute milliseconds from device boot when these stats were sampled
  optional int64 time_stamp_ms = 1;

  // The RSSI at the sample time
  optional int32 rssi = 2;

  // Link speed at the sample time in Mbps
  optional int32 link_speed_mbps = 3;

  // The total number of tx success counted from the last radio chip reset
  optional int64 total_tx_success = 4;

  // The total number of MPDU data packet retries counted from the last radio chip reset
  optional int64 total_tx_retries = 5;

  // The total number of tx bad counted from the last radio chip reset
  optional int64 total_tx_bad = 6;

  // The total number of rx success counted from the last radio chip reset
  optional int64 total_rx_success = 7;

  // The total time the wifi radio is on in ms counted from the last radio chip reset
  optional int64 total_radio_on_time_ms = 8;

  // The total time the wifi radio is doing tx in ms counted from the last radio chip reset
  optional int64 total_radio_tx_time_ms = 9;

  // The total time the wifi radio is doing rx in ms counted from the last radio chip reset
  optional int64 total_radio_rx_time_ms = 10;

  // The total time spent on all types of scans in ms counted from the last radio chip reset
  optional int64 total_scan_time_ms = 11;

  // The total time spent on nan scans in ms counted from the last radio chip reset
  optional int64 total_nan_scan_time_ms = 12;

  // The total time spent on background scans in ms counted from the last radio chip reset
  optional int64 total_background_scan_time_ms = 13;

  // The total time spent on roam scans in ms counted from the last radio chip reset
  optional int64 total_roam_scan_time_ms = 14;

  // The total time spent on pno scans in ms counted from the last radio chip reset
  optional int64 total_pno_scan_time_ms = 15;

  // The total time spent on hotspot2.0 scans and GAS exchange in ms counted from the last radio
  // chip reset
  optional int64 total_hotspot_2_scan_time_ms = 16;

  // Internal framework Wifi score
  optional int32 wifi_score = 17;

  // Wifi usability score provided by external system app
  optional int32 wifi_usability_score = 18;

  // Sequence number from external system app to framework
  optional int32 seq_num_to_framework = 19;

  // The total time CCA is on busy status on the current frequency in ms
  // counted from the last radio chip reset
  optional int64 total_cca_busy_freq_time_ms = 20;

  // The total radio on time of the current frequency from the last radio
  // chip reset
  optional int64 total_radio_on_freq_time_ms = 21;

  // The total number of beacons received from the last radio chip reset
  optional int64 total_beacon_rx = 22;

  // Prediction horizon (in second) of Wifi usability score provided by external
  // system app
  optional int32 prediction_horizon_sec = 23;

  // The link probe status since last stats update
  optional LinkProbeStatus probe_status_since_last_update = 24;

  // The elapsed time of the most recent link probe since last stats update;
  optional int32 probe_elapsed_time_since_last_update_ms = 25;

  // The MCS rate of the most recent link probe since last stats update
  optional int32 probe_mcs_rate_since_last_update = 26;

  // Rx link speed at the sample time in Mbps
  optional int32 rx_link_speed_mbps = 27;

  // Sequence number generated by framework
  optional int32 seq_num_inside_framework = 28;

  // Whether current entry is for the same BSSID on the same frequency compared
  // to last entry
  optional bool is_same_bssid_and_freq = 29;

  // Cellular data network type currently in use on the device for data transmission
  optional CellularDataNetworkType cellular_data_network_type = 30;

  // Cellular signal strength in dBm, NR: CsiRsrp, LTE: Rsrp, WCDMA/TDSCDMA: Rscp,
  // CDMA: Rssi, EVDO: Rssi, GSM: Rssi
  optional int32 cellular_signal_strength_dbm = 31;

  // Cellular signal strength in dB, NR: CsiSinr, LTE: Rsrq, WCDMA: EcNo, TDSCDMA: invalid,
  // CDMA: Ecio, EVDO: SNR, GSM: invalid */
  optional int32 cellular_signal_strength_db = 32;

  // Whether the primary registered cell of current entry is same as that of previous entry
  optional bool is_same_registered_cell = 33;

  // The device mobility state
  optional DeviceMobilityStatePnoScanStats.DeviceMobilityState
          device_mobility_state = 34;
}

message WifiUsabilityStats {
  enum Label {
    // Default label
    LABEL_UNKNOWN = 0;

    // Wifi is usable
    LABEL_GOOD = 1;

    // Wifi is unusable
    LABEL_BAD = 2;
  }

  enum UsabilityStatsTriggerType {
    // Default/Invalid event
    TYPE_UNKNOWN = 0;

    // There is a data stall from tx failures
    TYPE_DATA_STALL_BAD_TX = 1;

    // There is a data stall from rx failures
    TYPE_DATA_STALL_TX_WITHOUT_RX = 2;

    // There is a data stall from both tx and rx failures
    TYPE_DATA_STALL_BOTH = 3;

    // Firmware generated an alert
    TYPE_FIRMWARE_ALERT = 4;

    // IP Manager lost reachability to network neighbors
    TYPE_IP_REACHABILITY_LOST = 5;
  }

  // The current wifi usability state
  optional Label label = 1;

  // The list of timestamped wifi usability stats
  repeated WifiUsabilityStatsEntry stats = 2;

  // What event triggered WifiUsabilityStats.
  optional UsabilityStatsTriggerType trigger_type = 3;

  // Firmware alert code. Only valid when the stats was triggered by a firmware
  // alert, otherwise -1.
  optional int32 firmware_alert_code = 4 [default = -1];

  // Absolute milliseconds from device boot when these stats were sampled
  optional int64 time_stamp_ms = 5;
}

message DeviceMobilityStatePnoScanStats {
  // see WifiManager.DEVICE_MOBILITY_STATE_* constants
  enum DeviceMobilityState {
    // Unknown mobility
    UNKNOWN = 0;

    // High movement
    HIGH_MVMT = 1;

    // Low movement
    LOW_MVMT = 2;

    // Stationary
    STATIONARY = 3;
  }

  // The device mobility state
  optional DeviceMobilityState device_mobility_state = 1;

  // The number of times that this state was entered
  optional int32 num_times_entered_state = 2;

  // The total duration elapsed while in this mobility state, in ms
  optional int64 total_duration_ms = 3;

  // the total duration elapsed while in this mobility state with PNO scans running, in ms
  optional int64 pno_duration_ms = 4;
}

// The information about the Wifi P2p events.
message WifiP2pStats {

  // Group event list tracking sessions and client counts in tethered mode.
  repeated GroupEvent group_event = 1;

  // Session information that gets logged for every Wifi P2p connection.
  repeated P2pConnectionEvent connection_event = 2;

  // Number of persistent group in the user profile.
  optional int32 num_persistent_group = 3;

  // Number of peer scan.
  optional int32 num_total_peer_scans = 4;

  // Number of service scan.
  optional int32 num_total_service_scans = 5;
}

message P2pConnectionEvent {

  enum ConnectionType {

    // fresh new connection.
    CONNECTION_FRESH = 0;

    // reinvoke a group.
    CONNECTION_REINVOKE = 1;

    // create a group with the current device as the group owner locally.
    CONNECTION_LOCAL = 2;

    // create a group or join a group with config.
    CONNECTION_FAST = 3;
  }

  enum ConnectivityLevelFailure {

    // Failure is unknown.
    CLF_UNKNOWN = 0;

    // No failure.
    CLF_NONE = 1;

    // Timeout for current connecting request.
    CLF_TIMEOUT = 2;

    // The connecting request is canceled by the user.
    CLF_CANCEL = 3;

    // Provision discovery failure, e.g. no pin code, timeout, rejected by the peer.
    CLF_PROV_DISC_FAIL = 4;

    // Invitation failure, e.g. rejected by the peer.
    CLF_INVITATION_FAIL = 5;

    // Incoming request is rejected by the user.
    CLF_USER_REJECT = 6;

    // New connection request is issued before ending previous connecting request.
    CLF_NEW_CONNECTION_ATTEMPT = 7;
  }

  // WPS method.
  enum WpsMethod {
    // WPS is skipped for Group Reinvoke.
    WPS_NA = -1;

    // Push button configuration.
    WPS_PBC = 0;

    // Display pin method configuration - pin is generated and displayed on device.
    WPS_DISPLAY = 1;

    // Keypad pin method configuration - pin is entered on device.
    WPS_KEYPAD = 2;

    // Label pin method configuration - pin is labelled on device.
    WPS_LABEL = 3;
  }

  // Start time of the connection.
  optional int64 start_time_millis = 1;

  // Type of the connection.
  optional ConnectionType connection_type = 2;

  // WPS method.
  optional WpsMethod wps_method = 3 [default = WPS_NA];

  // Duration to connect.
  optional int32 duration_taken_to_connect_millis = 4;

  // Failures that happen at the connectivity layer.
  optional ConnectivityLevelFailure connectivity_level_failure_code = 5;
}

// GroupEvent tracking group information from GroupStarted to GroupRemoved.
message GroupEvent {

  enum GroupRole {

    GROUP_OWNER = 0;

    GROUP_CLIENT = 1;
  }

  // The ID of network in supplicant for this group.
  optional int32 net_id = 1;

  // Start time of the group.
  optional int64 start_time_millis = 2;

  // Channel frequency used for Group.
  optional int32 channel_frequency = 3;

  // Is group owner or group client.
  optional GroupRole group_role = 5;

  // Number of connected clients.
  optional int32 num_connected_clients = 6;

  // Cumulative number of connected clients.
  optional int32 num_cumulative_clients = 7;

  // The session duration.
  optional int32 session_duration_millis = 8;

  // The idle duration. A group without any client is in idle.
  optional int32 idle_duration_millis = 9;
}

// Easy Connect (DPP)
message WifiDppLog {
  reserved 6;

  // Number of Configurator-Initiator requests
  optional int32 num_dpp_configurator_initiator_requests = 1;

  // Number of Enrollee-Initiator requests
  optional int32 num_dpp_enrollee_initiator_requests = 2;

  // Easy Connect (DPP) Enrollee success
  optional int32 num_dpp_enrollee_success = 3;

  // Easy Connect (DPP) Configurator success code bucket
  repeated DppConfiguratorSuccessStatusHistogramBucket dpp_configurator_success_code = 4;

  // Easy Connect (DPP) failure code bucket
  repeated DppFailureStatusHistogramBucket dpp_failure_code = 5;

  // Easy Connect (DPP) operation time bucket
  repeated HistogramBucketInt32 dpp_operation_time = 7;

  // Histogram bucket for Wi-Fi DPP configurator success
  message DppConfiguratorSuccessStatusHistogramBucket {
    // status type defining the bucket
    optional DppConfiguratorSuccessCode dpp_status_type = 1;

    // number of samples in the bucket
    optional int32 count = 2;
  }

  // Histogram bucket for Wi-Fi DPP failures
  message DppFailureStatusHistogramBucket {
    // status type defining the bucket
    optional DppFailureCode dpp_status_type = 1;

    // number of samples in the bucket
    optional int32 count = 2;
  }

  enum DppConfiguratorSuccessCode {
    // Unknown success code
    EASY_CONNECT_EVENT_SUCCESS_UNKNOWN = 0;

    // Easy Connect Configurator success event: Configuration sent to enrollee
    EASY_CONNECT_EVENT_SUCCESS_CONFIGURATION_SENT = 1;
  }

  enum DppFailureCode {
    // Unknown failure
    EASY_CONNECT_EVENT_FAILURE_UNKNOWN = 0;

    // Easy Connect Failure event: Scanned QR code is either not a Easy Connect URI, or the Easy
    // Connect URI has errors.
    EASY_CONNECT_EVENT_FAILURE_INVALID_URI = 1;

    // Easy Connect Failure event: Bootstrapping/Authentication initialization process failure.
    EASY_CONNECT_EVENT_FAILURE_AUTHENTICATION = 2;

    // Easy Connect Failure event: Both devices are implementing the same role and are
    // incompatible.
    EASY_CONNECT_EVENT_FAILURE_NOT_COMPATIBLE = 3;

    // Easy Connect Failure event: Configuration process has failed due to malformed message.
    EASY_CONNECT_EVENT_FAILURE_CONFIGURATION = 4;

    // Easy Connect Failure event: Easy Connect request while in another Easy Connect exchange.
    EASY_CONNECT_EVENT_FAILURE_BUSY = 5;

    // Easy Connect Failure event: No response from the peer.
    EASY_CONNECT_EVENT_FAILURE_TIMEOUT = 6;

    // Easy Connect Failure event: General protocol failure.
    EASY_CONNECT_EVENT_FAILURE_GENERIC = 7;

    // Easy Connect Failure event: Feature or option is not supported.
    EASY_CONNECT_EVENT_FAILURE_NOT_SUPPORTED = 8;

    // Easy Connect Failure event: Invalid network provided to Easy Connect configurator.
    // Network must either be WPA3-Personal (SAE) or WPA2-Personal (PSK).
    EASY_CONNECT_EVENT_FAILURE_INVALID_NETWORK = 9;
  }
}

// WifiConfigStore read/write metrics.
message WifiConfigStoreIO {
  // Histogram of config store read durations.
  repeated DurationBucket read_durations = 1;

  // Histogram of config store write durations.
  repeated DurationBucket write_durations = 2;

  // Total Number of instances of write/read duration in this duration bucket.
  message DurationBucket {
    // Bucket covers duration : [range_start_ms, range_end_ms)
    // The (inclusive) lower bound of read/write duration represented by this bucket
    optional int32 range_start_ms = 1;

    // The (exclusive) upper bound of read/write duration represented by this bucket
    optional int32 range_end_ms = 2;

    // Number of read/write durations that fit into this bucket
    optional int32 count = 3;
  }
}

// Histogram bucket counting with int32. Range is [start, end)
message HistogramBucketInt32 {
  // lower range of the bucket (inclusive)
  optional int32 start = 1;

  // upper range of the bucket (exclusive)
  optional int32 end = 2;

  // number of samples in the bucket
  optional int32 count = 3;
}

// Counts occurrences of a int32 key
message Int32Count {
  // the key
  optional int32 key = 1;

  // the count
  optional int32 count = 2;
}

message LinkProbeStats {
  enum LinkProbeFailureReason {
    // unknown reason
    LINK_PROBE_FAILURE_REASON_UNKNOWN = 0;

    // Specified MCS rate when it is unsupported by the driver.
    LINK_PROBE_FAILURE_REASON_MCS_UNSUPPORTED = 1;

    // Driver reported that no ACK was received for the transmitted probe.
    LINK_PROBE_FAILURE_REASON_NO_ACK = 2;

    // Driver failed to report on the status of the transmitted probe within the timeout.
    LINK_PROBE_FAILURE_REASON_TIMEOUT = 3;

    // An existing link probe is in progress.
    LINK_PROBE_FAILURE_REASON_ALREADY_STARTED = 4;
  }

  // Counts the number of failures for each failure reason.
  message LinkProbeFailureReasonCount {
    // The failure reason.
    optional LinkProbeFailureReason failure_reason = 1;

    // The number of occurrences for this failure reason.
    optional int32 count = 2;
  }

  // Counts the number of link probes for each experiment.
  message ExperimentProbeCounts {
    // The experiment ID.
    optional string experiment_id = 1;

    // The number of link probes triggered for this experiment.
    optional int32 probe_count = 2;
  }

  // Counts the occurrences of RSSI values when a link probe succeeds.
  repeated Int32Count success_rssi_counts = 1;

  // Counts the occurrences of RSSI values when a link probe fails.
  repeated Int32Count failure_rssi_counts = 2;

  // Counts the occurrences of Link Speed values when a link probe succeeds.
  repeated Int32Count success_link_speed_counts = 3;

  // Counts the occurrences of Link Speed values when a link probe fails.
  repeated Int32Count failure_link_speed_counts = 4;

  // Histogram for the number of seconds since the last TX success when a link probe succeeds.
  repeated HistogramBucketInt32 success_seconds_since_last_tx_success_histogram = 5;

  // Histogram for the number of seconds since the last TX success when a link probe fails.
  repeated HistogramBucketInt32 failure_seconds_since_last_tx_success_histogram = 6;

  // Histogram for the elapsed time of successful link probes, in ms.
  repeated HistogramBucketInt32 success_elapsed_time_ms_histogram = 7;

  // Counts the occurrences of error codes for failed link probes.
  repeated LinkProbeFailureReasonCount failure_reason_counts = 8;

  // Counts the number of link probes for each experiment.
  repeated ExperimentProbeCounts experiment_probe_counts = 9;
}

// Stores the decisions that were made by a experiment when compared against another experiment
message NetworkSelectionExperimentDecisions {
  // the id of one experiment
  optional int32 experiment1_id = 1;

  // the id of the other experiment
  optional int32 experiment2_id = 2;

  // Counts occurrences of the number of network choices there were when experiment1 makes the
  // same network selection as experiment2.
  // The keys are the number of network choices, and the values are the number of occurrences of
  // this number of network choices when exp1 and exp2 make the same network selection.
  repeated Int32Count same_selection_num_choices_counter = 3;

  // Counts occurrences of the number of network choices there were when experiment1 makes the
  // same network selection as experiment2.
  // The keys are the number of network choices, and the values are the number of occurrences of
  // this number of network choices when exp1 and exp2 make different network selections.
  // Note that it is possible for the network selection to be different even when there only exists
  // a single network choice, since choosing not to connect to that network is a valid choice.
  repeated Int32Count different_selection_num_choices_counter = 4;
}

// NetworkRequest API metrics.
message WifiNetworkRequestApiLog {
  // Number of requests via this API surface.
  optional int32 num_request = 1;

  // Histogram of requests via this API surface to number of networks matched in scan results.
  repeated HistogramBucketInt32 network_match_size_histogram = 2;

  // Number of successful network connection from this API.
  optional int32 num_connect_success = 3;

  // Number of requests via this API surface that bypassed user approval.
  optional int32 num_user_approval_bypass = 4;

  // Number of requests via this API surface that was rejected by the user.
  optional int32 num_user_reject = 5;

  // Number of unique apps using this API surface.
  optional int32 num_apps = 6;
}

// NetworkSuggestion API metrics.
message WifiNetworkSuggestionApiLog {
  // Number of modifications to their suggestions by apps.
  optional int32 num_modification = 1;

  // Number of successful network connection from app suggestions.
  optional int32 num_connect_success = 2;

  // Number of network connection failures from app suggestions.
  optional int32 num_connect_failure = 3;

  // Histogram for size of the network lists provided by various apps on the device.
  repeated HistogramBucketInt32 network_list_size_histogram = 4;
}

// WifiLock metrics
message WifiLockStats {
    // Amount of time wifi is actively in HIGH_PERF mode (ms)
    // This means the lock takes effect and the device takes the actions required for this mode
    optional int64 high_perf_active_time_ms = 1;

    // Amount of time wifi is actively in LOW_LATENCY mode (ms)
    // This means the lock takes effect and the device takes the actions required for this mode
    optional int64 low_latency_active_time_ms = 2;

    // Histogram of HIGH_PERF lock acquisition duration (seconds)
    // Note that acquiring the lock does not necessarily mean that device is actively in that mode
    repeated HistogramBucketInt32 high_perf_lock_acq_duration_sec_histogram = 3;

    // Histogram of LOW_LATENCY lock acquisition duration (seconds)
    // Note that acquiring the lock does not necessarily mean that device is actively in that mode
    repeated HistogramBucketInt32 low_latency_lock_acq_duration_sec_histogram = 4;

    // Histogram of HIGH_PERF active session duration (seconds)
    // This means the lock takes effect and the device takes the actions required for this mode
    repeated HistogramBucketInt32 high_perf_active_session_duration_sec_histogram = 5;

    // Histogram of LOW_LATENCY active session duration (seconds)
    // This means the lock takes effect and the device takes the actions required for this mode
    repeated HistogramBucketInt32 low_latency_active_session_duration_sec_histogram = 6;
}

// Stats on number of times Wi-Fi is turned on/off though the WifiManager#setWifiEnabled API
message WifiToggleStats {
  // Number of time Wi-Fi is turned on by privileged apps
  optional int32 num_toggle_on_privileged = 1;

  // Number of time Wi-Fi is turned off by privileged apps
  optional int32 num_toggle_off_privileged = 2;

  // Number of time Wi-Fi is turned on by normal apps
  optional int32 num_toggle_on_normal = 3;

  // Number of time Wi-Fi is turned off by normal apps
  optional int32 num_toggle_off_normal = 4;
}

// Information about the Passpoint provision metrics.
message PasspointProvisionStats {
  enum ProvisionFailureCode {
    // provisioning failure for unknown reason.
    OSU_FAILURE_UNKNOWN = 0;

    // The reason code for Provisioning Failure due to connection failure to OSU AP.
    OSU_FAILURE_AP_CONNECTION = 1;

    // The reason code for invalid server URL address.
    OSU_FAILURE_SERVER_URL_INVALID = 2;

    // The reason code for provisioning failure due to connection failure to the server.
    OSU_FAILURE_SERVER_CONNECTION = 3;

    // The reason code for provisioning failure due to invalid server certificate.
    OSU_FAILURE_SERVER_VALIDATION = 4;

    // The reason code for provisioning failure due to invalid service provider.
    OSU_FAILURE_SERVICE_PROVIDER_VERIFICATION = 5;

    // The reason code for provisioning failure when a provisioning flow is aborted.
    OSU_FAILURE_PROVISIONING_ABORTED = 6;

    // The reason code for provisioning failure when a provisioning flow is not possible.
    OSU_FAILURE_PROVISIONING_NOT_AVAILABLE = 7;

    // The reason code for provisioning failure due to invalid web url format for an OSU web page.
    OSU_FAILURE_INVALID_URL_FORMAT_FOR_OSU = 8;

    // The reason code for provisioning failure when a command received is not the expected command
    // type.
    OSU_FAILURE_UNEXPECTED_COMMAND_TYPE = 9;

    // The reason code for provisioning failure when a SOAP message is not the expected message
    // type.
    OSU_FAILURE_UNEXPECTED_SOAP_MESSAGE_TYPE = 10;

    // The reason code for provisioning failure when a SOAP message exchange fails.
    OSU_FAILURE_SOAP_MESSAGE_EXCHANGE = 11;

    // The reason code for provisioning failure when a redirect listener fails to start.
    OSU_FAILURE_START_REDIRECT_LISTENER = 12;

    // The reason code for provisioning failure when a redirect listener timed out to receive a HTTP
    // redirect response.
    OSU_FAILURE_TIMED_OUT_REDIRECT_LISTENER = 13;

    // The reason code for provisioning failure when there is no OSU activity to listen to intent.
    OSU_FAILURE_NO_OSU_ACTIVITY_FOUND = 14;

    // The reason code for provisioning failure when the status of a SOAP message is not the
    // expected message status.
    OSU_FAILURE_UNEXPECTED_SOAP_MESSAGE_STATUS = 15;

    // The reason code for provisioning failure when there is no PPS MO.
    OSU_FAILURE_NO_PPS_MO = 16;

    // The reason code for provisioning failure when there is no AAAServerTrustRoot node in a PPS
    // MO.
    OSU_FAILURE_NO_AAA_SERVER_TRUST_ROOT_NODE = 17;

    // The reason code for provisioning failure when there is no TrustRoot node for remediation
    // server in a PPS MO.
    OSU_FAILURE_NO_REMEDIATION_SERVER_TRUST_ROOT_NODE = 18;

    // The reason code for provisioning failure when there is no TrustRoot node for policy server in
    // a PPS MO.
    OSU_FAILURE_NO_POLICY_SERVER_TRUST_ROOT_NODE = 19;

    // The reason code for provisioning failure when failing to retrieve trust root certificates
    // used for validating server certificate for AAA, Remediation and Policy server.
    OSU_FAILURE_RETRIEVE_TRUST_ROOT_CERTIFICATES = 20;

    // The reason code for provisioning failure when there is no trust root certificate for AAA
    // server.
    OSU_FAILURE_NO_AAA_TRUST_ROOT_CERTIFICATE = 21;

    // The reason code for provisioning failure when a {@link PasspointConfiguration} is failed to
    // install.
    OSU_FAILURE_ADD_PASSPOINT_CONFIGURATION = 22;

    // The reason code for provisioning failure when an {@link OsuProvider} is not found for
    // provisioning.
    OSU_FAILURE_OSU_PROVIDER_NOT_FOUND = 23;
  }

  // Number of passpoint provisioning success
  optional int32 num_provision_success = 1;

  // Count for passpoint provisioning failure
  repeated ProvisionFailureCount provision_failure_count = 2;

  // Number of occurrences of a specific passpoint provision failure code
  message ProvisionFailureCount {
    // Failure code
    optional ProvisionFailureCode failure_code = 1;

    // Number of failure for the failure_code.
    optional int32 count = 2;
  }
}
